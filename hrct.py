#!/usr/bin/env python3

# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file './hrct.ui'
#
# Created by: PyQt5 UI code generator 5.15.6
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

# %%
# Importing Libraries
from PyQt5 import QtCore, QtGui, QtWidgets
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar
import matplotlib.pyplot as plt
import os
import numpy as np
import matplotlib.pyplot as plt
from pydicom import dcmread
import cv2 as ocv
from sklearn.cluster import KMeans
from skimage import measure, morphology

# %%
# Scan Sample Class
class scan:
    def __init__(self, addr):
        '''
        Initializes class for sample
        
        Method Input:
        =============
        addr: Absolute address of th samples directory with slices only
        
        Method Output:
        ==============
        None
        '''
        self.address = addr
        self.all_masks = list()
        self.resize_pix = 1024
        self.scan_stack = self.__get_stack__()
    
    def __load_slices__(self):
        '''
        This method loads slices of a sample into memory
        
        Method Input:
        =============
        None
        
        Method Output:
        ==============
        Slices files
        '''
        slice_files = [dcmread(f'{self.address}/{i}') for i in os.listdir(self.address)]
        slice_files.sort(key = lambda i: int(i.InstanceNumber))
        try:
            thickness = np.abs(slice_files[0].ImagePositionPatient[2] - slice_files[1].ImagePositionPatient[2])
        except:
            thickness = np.abs(slice_files[0].SliceLocation - slice_files[1].SliceLocation)
        for s in slice_files:
            s.SliceThickness = thickness
        return slice_files
    
    def __get_stack__(self):
        '''
        This method process slices into image stack
        
        Method Input:
        =============
        None
        
        Method Output:
        ==============
        Image stack of Samples in Numpy arrays
        '''
        slices = self.__load_slices__()
        img = np.stack([s.pixel_array for s in slices])
        img = img.astype(np.int16)
        img[img == -2000] = 0
        intercept = slices[0].RescaleIntercept
        slope = slices[0].RescaleSlope
        if slope != 1:
            img = slope * img.astype(np.float64)
            img = img.astype(np.int16)
        img += np.int16(intercept)
        return np.array(img, dtype=np.int16)
    
    def __blob__(self, img):
        '''
        This method is used to find blob in the subject image
        
        Method Input:
        =============
        img: Image to find blob
        
        Method Output:
        ==============
        Processed Image, Keypoints
        '''
        img = np.where(img > 100, 0, 255)
        img = img.astype('uint8')
        param = ocv.SimpleBlobDetector_Params()
        param.filterByArea = True
        param.filterByCircularity = False
        param.filterByConvexity = False
        param.filterByInertia = False
        param.filterByColor = True
        blob = ocv.SimpleBlobDetector_create(param)
        kp = blob.detect(img)
        return img, kp
    
    def __area_finder__(self, ident_blob, kps, mask):
        '''
        This method is used to find defective area in a given blobbed image
        
        Method Input:
        =============
        ident_blob: Blobbed Image
        kps: Blob keypoints
        mask: Masked image after segmentation
        
        Method Output:
        ==============
        Tuple of sum of defective and mask pixles
        '''
        base = np.zeros((ident_blob.shape[0], ident_blob.shape[1])).astype('uint8')
        for i in list(kps):
            base = ocv.circle(base, (int(i.pt[0]), int(i.pt[1])), int(i.size//2), 1, -1)
        base = mask * base
        return (np.sum(base), np.sum(mask))
        
    def get_mask(self, idx):
        '''
        This method is used to process single slice to get raw results
        
        Method Input:
        =============
        idx: Index of slice
        
        Method Output:
        ==============
        None
        '''
        img = self.scan_stack[idx]
        row_size, col_size= img.shape[0], img.shape[1]
        mean, std = np.mean(img), np.std(img)
        img = img-mean
        img = img/std
        middle = img[int(col_size/5):int(col_size/5*4),int(row_size/5):int(row_size/5*4)] 
        mean = np.mean(middle)  
        max, min = np.max(img), np.min(img)
        img[img==max]=mean
        img[img==min]=mean
        # Image Clustering for Segmentation
        # =================================
        kmeans = KMeans(n_clusters=2).fit(np.reshape(middle,[np.prod(middle.shape),1]))
        centers = sorted(kmeans.cluster_centers_.flatten())
        threshold = np.mean(centers)
        # Threshold Image
        # ===============
        thresh_img = np.where(img<threshold,1.0,0.0)
        eroded = morphology.erosion(thresh_img,np.ones([3,3]))
        # Dilated Image after Erosion
        # ===========================
        dilation = morphology.dilation(eroded,np.ones([8,8]))
        # Colored Segmented Image
        # =======================
        labels = measure.label(dilation)
        # Segmentation Masking
        # ====================
        label_vals = np.unique(labels)
        regions = measure.regionprops(labels)
        good_labels = []
        for prop in regions:
            B = prop.bbox
            if B[2]-B[0]<row_size/10*9 and B[3]-B[1]<col_size/10*9 and B[0]>row_size/5 and B[2]<col_size/5*4:
                good_labels.append(prop.label)
        mask = np.ndarray([row_size,col_size],dtype=np.int8)
        mask[:] = 0
        for N in good_labels:
            mask = mask + np.where(labels==N,1,0)
        mask = morphology.dilation(mask,np.ones([10,10]))
        # Histogram Equalization
        # ======================
        norm_img = (self.scan_stack[idx] - np.min(self.scan_stack[idx])) / (np.max(self.scan_stack[idx]) - np.min(self.scan_stack[idx]))
        img_equal = ocv.equalizeHist((norm_img * 255).astype('uint8'))
        # Identification
        # ==============
        blob_template, kps = self.__blob__(img_equal)
        final_kps = list()
        for i in list(kps):
            if mask[int(i.pt[1]), int(i.pt[0])]==1:
                final_kps.append(i)
        ident_blob =  ocv.drawKeypoints(blob_template, final_kps, None, [255, 0, 0], ocv.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS)
        # Area Finder
        # ===========
        area1 = self.__area_finder__(ident_blob, final_kps, mask)
        return img, thresh_img, dilation, labels, mask, mask*img, img_equal, ident_blob, area1

# GUI Class
class Ui_HRCT(object):
    def setupUi(self, HRCT):
        HRCT.setObjectName("HRCT")
        HRCT.resize(967, 824)
        self.instruct1 = QtWidgets.QLabel(HRCT)
        self.instruct1.setGeometry(QtCore.QRect(10, 140, 261, 16))
        self.instruct1.setObjectName("instruct1")
        self.loader1 = QtWidgets.QPushButton(HRCT)
        self.loader1.setGeometry(QtCore.QRect(300, 160, 101, 23))
        self.loader1.setObjectName("loader1")
        self.lister1 = QtWidgets.QFontComboBox(HRCT)
        self.lister1.setGeometry(QtCore.QRect(10, 160, 281, 23))
        self.lister1.setCurrentText("")
        self.lister1.setIconSize(QtCore.QSize(16, 16))
        self.lister1.setObjectName("lister1")
        self.reset1 = QtWidgets.QPushButton(HRCT)
        self.reset1.setGeometry(QtCore.QRect(410, 160, 91, 23))
        self.reset1.setObjectName("reset1")
        self.ggo_label = QtWidgets.QLabel(HRCT)
        self.ggo_label.setGeometry(QtCore.QRect(510, 160, 141, 21))
        self.ggo_label.setObjectName("ggo_label")
        self.ggo_value = QtWidgets.QLabel(HRCT)
        self.ggo_value.setGeometry(QtCore.QRect(660, 160, 161, 21))
        self.ggo_value.setObjectName("ggo_value")
        self.verticalLayoutWidget = QtWidgets.QWidget(HRCT)
        self.verticalLayoutWidget.setGeometry(QtCore.QRect(10, 290, 951, 531))
        self.verticalLayoutWidget.setObjectName("verticalLayoutWidget")
        self.plotlayout = QtWidgets.QVBoxLayout(self.verticalLayoutWidget)
        self.plotlayout.setContentsMargins(0, 0, 0, 0)
        self.plotlayout.setObjectName("plotlayout")
        self.widget = QtWidgets.QWidget(HRCT)
        self.widget.setGeometry(QtCore.QRect(10, 10, 491, 57))
        self.widget.setObjectName("widget")
        self.mainheader1 = QtWidgets.QVBoxLayout(self.widget)
        self.mainheader1.setContentsMargins(0, 0, 0, 0)
        self.mainheader1.setObjectName("mainheader1")
        self.header1 = QtWidgets.QLabel(self.widget)
        font = QtGui.QFont()
        font.setFamily("Sans Serif")
        font.setPointSize(14)
        font.setBold(True)
        font.setItalic(True)
        font.setUnderline(False)
        font.setWeight(75)
        self.header1.setFont(font)
        self.header1.setObjectName("header1")
        self.mainheader1.addWidget(self.header1)
        self.subheader1 = QtWidgets.QLabel(self.widget)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.subheader1.setFont(font)
        self.subheader1.setObjectName("subheader1")
        self.mainheader1.addWidget(self.subheader1)
        self.div1 = QtWidgets.QFrame(self.widget)
        self.div1.setFrameShape(QtWidgets.QFrame.HLine)
        self.div1.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.div1.setObjectName("div1")
        self.mainheader1.addWidget(self.div1)
        self.widget1 = QtWidgets.QWidget(HRCT)
        self.widget1.setGeometry(QtCore.QRect(10, 80, 491, 46))
        self.widget1.setObjectName("widget1")
        self.homedirectory = QtWidgets.QVBoxLayout(self.widget1)
        self.homedirectory.setContentsMargins(0, 0, 0, 0)
        self.homedirectory.setObjectName("homedirectory")
        self.instruct2 = QtWidgets.QLabel(self.widget1)
        self.instruct2.setObjectName("instruct2")
        self.homedirectory.addWidget(self.instruct2)
        self.gethomedir = QtWidgets.QLineEdit(self.widget1)
        self.gethomedir.setObjectName("gethomedir")
        self.homedirectory.addWidget(self.gethomedir)
        self.widget2 = QtWidgets.QWidget(HRCT)
        self.widget2.setGeometry(QtCore.QRect(10, 190, 951, 46))
        self.widget2.setObjectName("widget2")
        self.loaderbar1 = QtWidgets.QVBoxLayout(self.widget2)
        self.loaderbar1.setContentsMargins(0, 0, 0, 0)
        self.loaderbar1.setObjectName("loaderbar1")
        self.loaderlabel = QtWidgets.QLabel(self.widget2)
        self.loaderlabel.setObjectName("loaderlabel")
        self.loaderbar1.addWidget(self.loaderlabel)
        self.loaderprogress = QtWidgets.QProgressBar(self.widget2)
        self.loaderprogress.setProperty("value", 0)
        self.loaderprogress.setObjectName("loaderprogress")
        self.loaderbar1.addWidget(self.loaderprogress)
        self.widget3 = QtWidgets.QWidget(HRCT)
        self.widget3.setGeometry(QtCore.QRect(10, 240, 951, 38))
        self.widget3.setObjectName("widget3")
        self.viewer1 = QtWidgets.QVBoxLayout(self.widget3)
        self.viewer1.setContentsMargins(0, 0, 0, 0)
        self.viewer1.setObjectName("viewer1")
        self.viewerlabel1 = QtWidgets.QLabel(self.widget3)
        self.viewerlabel1.setObjectName("viewerlabel1")
        self.viewer1.addWidget(self.viewerlabel1)
        self.slider1 = QtWidgets.QSlider(self.widget3)
        self.slider1.setOrientation(QtCore.Qt.Horizontal)
        self.slider1.setObjectName("slider1")
        self.viewer1.addWidget(self.slider1)

        self.retranslateUi(HRCT)
        QtCore.QMetaObject.connectSlotsByName(HRCT)

    def retranslateUi(self, HRCT):
        _translate = QtCore.QCoreApplication.translate
        HRCT.setWindowTitle(_translate("HRCT", "HRCT"))
        self.instruct1.setText(_translate("HRCT", "Please Select From the Following Samples"))
        self.loader1.setText(_translate("HRCT", "Load Sample"))
        self.reset1.setText(_translate("HRCT", "Reset"))
        self.ggo_label.setText(_translate("HRCT", "Ground Glass Opacity:"))
        self.ggo_value.setText(_translate("HRCT", "Null"))
        self.header1.setText(_translate("HRCT", "HRCT COVID-19 Detection"))
        self.subheader1.setText(_translate("HRCT", "A Joint Venture of PAF Hospital & AR Lab NUST"))
        self.instruct2.setText(_translate("HRCT", "Enter Absolute Address of Samples Directory"))
        self.loaderlabel.setText(_translate("HRCT", "Sample Loading Progress Bar"))
        self.viewerlabel1.setText(_translate("HRCT", "Sample Viewer"))
        self.starter()
    
    def starter(self):
        """
        This method initilizes main page and sets components
        """
        self.dicom_directory_identifier = 'DICOM'
        self.figure = plt.figure()
        self.canvas = FigureCanvas(self.figure)
        self.toolbar = NavigationToolbar(self.canvas, self)
        self.plotlayout.addWidget(self.toolbar)
        self.plotlayout.addWidget(self.canvas)
        self.setLayout(self.plotlayout)
        self.reseter1(True)
        self.gethomedir.textChanged.connect(self.get_home_directory)
        self.lister1.currentTextChanged.connect(self.get_sample_addr)
        self.loader1.clicked.connect(self.loader_clicker)
        self.reset1.clicked.connect(self.reseter1)
        self.slider1.valueChanged.connect(self.slider_changer)
    
    def get_home_directory(self, dir):
        """
        This method get home directory from user
        
        Method Input:
        =============
        dir: Gets written address by the user when text changes
        """
        try:
            self.sample_dirs = os.listdir(dir)
            _translate = QtCore.QCoreApplication.translate
            for i in range(len(self.sample_dirs)):
                if self.dicom_directory_identifier in os.listdir(dir + '/' + self.sample_dirs[i]):
                    self.lister1.addItem("")
                    self.lister1.setItemText(i, _translate("Dialog", self.sample_dirs[i]))
                    self.home_dir = dir
            self.clicker_ready = True
        except:
            self.clicker_ready = False
            self.lister1.clear()

    def get_sample_addr(self, addr):
        """
        This method creates absolute address of sample
        """
        self.current_sample = addr + '/' + self.dicom_directory_identifier
    
    def loader_clicker(self, clicker):
        """
        This method is executed when button is clicked for sample loading

        Method Input:
        =============
        clicker: Bool variable representing if button is clicked
        """
        if self.clicker_ready == True:
            self.clicker_ready = False
            try:
                if type(self.current_sample) == 'str':
                    None
            except:
                self.current_sample = self.lister1.currentText() + '/' + self.dicom_directory_identifier
            self.current_scan = scan(f'{self.home_dir}/{self.current_sample}')
            blob_area, mask_area = 0, 0
            for i in range(len(self.current_scan.scan_stack)):
                raw_img, thres_img, dilated, colored_labels, raw_mask, applied_mask, hist_equal, identify, area1 = self.current_scan.get_mask(i)
                blob_area += area1[0]
                mask_area += area1[1]
                self.current_scan.all_masks.append({
                    'raw_img': raw_img,
                    'threshold': thres_img,
                    'dilated': dilated,
                    'colored': colored_labels,
                    'raw_mask': raw_mask,
                    'applied_mask': applied_mask,
                    'histogram_equal': hist_equal,
                    'identify': identify,
                    'blob_area': area1[0],
                    'mask_area': area1[1]
                })
                self.loaderprogress.setValue(int((i/len(self.current_scan.scan_stack))*100)+1)
            self.total_ggo = (blob_area / mask_area) * 100
            _translate = QtCore.QCoreApplication.translate
            if (self.total_ggo*2)>=50:
                self.ggo_value.setText(_translate("Dialog", '{:.8f} %'.format(self.total_ggo)))
            else:
                self.ggo_value.setText(_translate("Dialog", '{:.8f} %'.format(self.total_ggo*2)))
            self.ggo_value.setStyleSheet("color: red;")
            self.slider1.setMinimum(0)
            self.slider1.setMaximum(len(self.current_scan.all_masks)-1)
            self.img_data_available = True
            self.slider_changer(0)
    
    def slider_changer(self, val1):
        """
        This method is executed when slider is changed or moved

        Method Inputs:
        ==============
        val1: Value of slider
        """
        if self.img_data_available == True:
            instance = self.current_scan.all_masks[val1]
            raw_img, thres_img, dilated, colored_labels, raw_mask = instance['raw_img'], instance['threshold'], instance['dilated'], instance['colored'], instance['raw_mask']
            applied_mask, hist_equal, identify, area1 = instance['applied_mask'], instance['histogram_equal'], instance['identify'], (instance['blob_area']/instance['mask_area'])*100
            self.figure.clear()
            ax1 = self.figure.add_subplot(241)
            ax2 = self.figure.add_subplot(242)
            ax3 = self.figure.add_subplot(243)
            ax4 = self.figure.add_subplot(244)
            ax5 = self.figure.add_subplot(245)
            ax6 = self.figure.add_subplot(246)
            ax7 = self.figure.add_subplot(247)
            ax8 = self.figure.add_subplot(248)
            ax1.imshow(raw_img, cmap='gray')
            ax1.set_title("Original")
            ax2.imshow(thres_img, cmap='gray')
            ax2.set_title("Threshold")
            ax3.imshow(dilated, cmap='gray')
            ax3.set_title("Erosion and Dilation")
            ax4.imshow(colored_labels)
            ax4.set_title("Color Segmentation")
            ax5.imshow(raw_mask, cmap='gray')
            ax5.set_title("Masking")
            ax6.imshow(applied_mask, cmap='gray')
            ax6.set_title("Mask Overlay")
            ax7.imshow(hist_equal, cmap='gray')
            ax7.set_title("Histogram Equalization")
            ax8.imshow(identify, cmap='gray')
            ax8.set_title("Identification")
            ax1.axis('off')
            ax2.axis('off')
            ax3.axis('off')
            ax4.axis('off')
            ax5.axis('off')
            ax6.axis('off')
            ax7.axis('off')
            ax8.axis('off')
            self.canvas.draw()

    def reseter1(self, clicker):
        """
        This method is executed when reset button is pressed

        Method Input:
        =============
        clicker: Bool variable representing if button is clicked
        """
        # self.home_dir = '/home/data_samples'
        self.home_dir = ''
        self.clicker_ready = False
        self.img_data_available = False
        _translate = QtCore.QCoreApplication.translate
        self.gethomedir.setText(_translate("Dialog", self.home_dir))
        self.get_home_directory(self.home_dir)
        self.ggo_value.setText(_translate("Dialog", "Null"))
        self.ggo_value.setStyleSheet("color: black;")
        self.loaderprogress.setValue(0)
        self.slider1.setMinimum(0)
        self.slider1.setMaximum(1)
        self.figure.clear()
        self.canvas.draw()
        try:
            del self.current_scan
            del self.total_ggo
        except:
            None

# Main Window Class
class main_window(QtWidgets.QMainWindow, Ui_HRCT):
    def __init__(self):
        """
        Class for dialog display
        Description:
        ============
        This method initialize display for HRCT tool
        """
        super().__init__()
        self.setupUi(self)

# %%
# Execution
if __name__=='__main__':
    app = QtWidgets.QApplication([])
    window = main_window()
    window.show()
    app.exec()
